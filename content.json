{"meta":{"title":"Hexo","subtitle":"","description":"","author":"吴红星","url":"https://wuhongxing.github.io","root":"/"},"pages":[],"posts":[{"title":"标签页通信","slug":"tab-communication","date":"2024-03-09T12:02:06.000Z","updated":"2024-03-09T12:05:20.457Z","comments":true,"path":"2024/03/09/tab-communication/","permalink":"https://wuhongxing.github.io/2024/03/09/tab-communication/","excerpt":"","text":"总结进行标签页通信的方式。 标签页通信 demo localStorage没有兼容性问题 123456789// 监听window.addEventListener(&#x27;storage&#x27;, (e) =&gt; &#123; if (e.key === &#x27;success&#x27;) &#123; console.log(&#x27;收到通知&#x27;, e.newValue, e.oldValue) &#125;&#125;)// 发送localStorage.setItem(&#x27;success&#x27;, Math.random()) broadcastChannel有兼容性问题，Safari 的兼容性较差，15.4 之后支持 1234567891011// 监听const channel = new BroadcastChannel(&#x27;success&#x27;)channel.onmessage = (e) =&gt; &#123; if (e.target.name === &#x27;success&#x27;) &#123; console.log(&#x27;收到通知&#x27;, e.data) &#125;&#125;// 发送const channel1 = new BroadcastChannel(&#x27;success&#x27;)channel1.postMessage(Math.random()) serviceWorker有兼容性问题，兼容性较差, 11.1 之后支持 注意点: service worker 会有缓存，调试时必须将所有页签关闭后重新打开 1234567891011// 监听navigator.serviceWorker.register(&#x27;./sw.js&#x27;).then(() =&gt; &#123; console.log(&#x27;sw 注册成功&#x27;)&#125;)navigator.serviceWorker.onmessage = (e) =&gt; &#123; console.log(&#x27;收到通知&#x27;) console.log(e)&#125;// 发送navigator.serviceWorker.controller.postMessage(Math.random()) websocket需要服务端进行支持 123456789101112// 监听const socket = new WebSocket(&#x27;ws://localhost:8000&#x27;);socket.onopen = function () &#123;&#125;;socket.onmessage = async function (e) &#123; console.log(&#x27;接收通知&#x27;, await e.data.text());&#125;;// 发送const socket1 = new WebSocket(&#x27;ws://localhost:8000&#x27;);socket1.send(Math.random()); sessionStorage、cookie、indexDB监听需要轮循，无法保证实时性 123456789101112// 监听let last;setInterval(() =&gt; &#123; recent = sessionStorage.getItem(&#x27;success&#x27;) if (last !== recent) &#123; last = recent console.log(&#x27;收到通知&#x27;, recent) &#125;&#125;, 1000);// 发送sessionStorage.setItem(&#x27;success&#x27;, Math.random())","categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://wuhongxing.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"}],"tags":[]},{"title":"type challenges","slug":"type-challenges","date":"2023-12-15T10:51:06.000Z","updated":"2024-02-18T05:17:04.000Z","comments":true,"path":"2023/12/15/type-challenges/","permalink":"https://wuhongxing.github.io/2023/12/15/type-challenges/","excerpt":"","text":"2024.2.18 更 重载: 方法同名，但是参数和返回值类型不一样1234567// 当传递了 key，返回对应 key 的值，没有传递 key，则返回整个对象useGray(): Record&lt;string, boolean&gt;useGray(key: string): booleanuseGray(key?: string): boolean | Record&lt;string, boolean&gt; &#123; // 具体实现&#125; 上面这个需求用泛型就无法实现了，很多三方库也有类似的用法。 2024.2.8 更 字符串转数字1type StringToNumber&lt;S extends string&gt; = S extends `$&#123;infer N extends number&#125;` ? N : number tsconfig配置项详解其是对整个 tsconfig 所在文件夹及子目录生效12345678910111213&#123; &quot;compilerOptions&quot;: &#123; &quot;module&quot;: &quot;commonjs&quot;, // 用来指定要使用的模块化的规范，默认 commonjs &quot;target&quot;: &quot;es2017&quot;, // 需要兼容到的版本（取决于你想运行在什么浏览器上面），默认 es3 &quot;lib&quot;: [&quot;ESNext&quot;], // 指定要包含在编译中的库文件，默认 [] &quot;path&quot;: &#123; &quot;app/*&quot;: [&quot;./src/app/*&quot;] &#125; // 将导入重新映射到其他查找位置 // 其他规则... &#125;, &quot;exclude&quot;: [&quot;node_modules&quot;, &quot;dist&quot;], // 排除特定文件 &quot;extends&quot;: &quot;./tsconfig.base.json&quot;,&#125; 可以使用 global.d.ts 在全局定义，也可以覆盖三方库中的定义可以使用下面这种方式来声明，也可以使用 export、import1234567/// &lt;reference path=&quot;./types/xxx.d.ts&quot; /&gt;declare module &#x27;xxx&#x27; &#123; export type Module = &#123; name: string &#125;&#125; 基础知识12type Name = &#123; name: string &#125;type Age = &#123; age: number &#125; 类型关系类型关系 类型之间的并集（|）会向上取顶部的类型。即 never | &#39;a&#39; =&gt; &#39;a&#39;，unknown | &#39;a&#39; =&gt; &#39;unknown&#39;类型之间的交集（&amp;）会向下取底部的类型。即 never &amp; &#39;a&#39; = never，unknown &amp; &#39;a&#39; =&gt; &#39;a&#39; bottom Type: nevertop Type: unknown既是 top Type 也是 bottom Type: any 类型 联合类型1type Union = Name | Age 交叉类型1type Intersection = Name &amp; Age 元组类型(TS 中的元组使用数组来表示)1type Turple = [Name, Age] 关键字 keyof: 将对象中所有的键取出来组成联合类型，如果这个类型是基本类型的话，就是将基本类型中的方法取出来组成联合类型1234// &#x27;name&#x27; | &#x27;age&#x27;type Keys = keyof Union// &quot;toFixed&quot; | &quot;toExponential&quot; | &quot;toPrecision&quot; | &quot;toString&quot; | &quot;toLocaleString&quot; | &quot;valueOf&quot;type NumberKeys = keyof number extends: 判断左右的类型是不是小于等于右边的类型1type Extends&lt;A, B&gt; = A extends B ? true : false infer: 推断真正的类型1type First&lt;T&gt; = T extends [infer A] ? A : any in: 遍历所有的 key1type In = &#123; [P in keyof Name]: Name[P] &#125; as: 转换对应的 key ‘&#96;’: 字符串1type As = &#123; [P in keyof Name as `get$&#123;P&#125;`]: Name[P] &#125; 7: is: 缩小类型1declare function isString(val: unknown) val is string thisType: 推断方法中的 this 拥有哪些方法和属性必须在 tsconfig.json 中配置 &quot;noImplicitThis&quot;: true1234567891011type GetComputed&lt;C&gt; = C extends Record&lt;string, (...args: any[]) =&gt; any&gt; ? &#123; [S in keyof C]: ReturnType&lt;C[S]&gt; &#125; : neverdeclare function SimpleVue&lt;D, C, M&gt;( options: &#123; data: (this: void) =&gt; D computed: C &amp; ThisType&lt;D&gt; methods: M &#125; &amp; ThisType&lt;D &amp; M &amp; GetComputed&lt;C&gt;&gt;): unknown 注意点：联合类型不需要使用 in 也是会触发其分发特性的 1type MyExclude&lt;T, U extends T&gt; = T extends U ? never : T 逆变 &#x2F; 协变暂时还没有搞清楚。大概就是参数和返回值都应该比当前设置的类型更小。 常见技巧获取数组长度1type Length&lt;T extends unknown[]&gt; = T[&#x27;length&#x27;] 联合两个数组1type Concat&lt;A extends unknown[], B extends unknown[]&gt; = [...A, ...B] 获取函数的返回值1type ReturnType&lt;T extends (...args: any) =&gt; any&gt; = T extends (...args: any) =&gt; infer R ? R : any; 元组、联合、交叉类型的互相转换这个里面使用到了协变和逆变。 1234567891011121314151617// 1. 元组转联合类型type TurpleToUnion&lt;T extends unknown[]&gt; = T[number]// 2. 联合类型转交叉类型type UnionToIntersection&lt;T&gt; = ( T extends object ? (k: T) =&gt; void : never) extends (k: infer U) =&gt; void ? U : never// 3. 联合类型转元组类型type LastInUnion&lt;U&gt; = UnionToIntersection&lt; U extends unknown ? (x: U) =&gt; 0 : never&gt; extends (x: infer L) =&gt; 0 ? L : nevertype UnionToTurple&lt;T, L = LastInUnion&lt;T&gt;&gt; = [T] extends [never] ? [] : [...UnionToTurple&lt;Exclude&lt;T, L&gt;&gt;, L] 字符串转元组123type StringToTurple&lt;T extends string&gt; = T extends `$&#123;infer F&#125;$&#123;infer L&#125;` ? [F, ...StringToTurple&lt;L&gt;] : [] 判断是不是 never&#x2F;any12type IsNever&lt;T&gt; = [T] extends [never] ? true : falsetype IsAny&lt;T&gt; = 0 extends (1 &amp; T) ? true : false 判断两个数字的大小123456789type IsLess&lt; A extends number, B extends number, I extends any[] = []&gt; = B extends I[&quot;length&quot;] ? true : A extends I[&quot;length&quot;] ? false : IsLess&lt;A, B, [...I, 0]&gt; 支持特定范围内的数字123456789type Range&lt; Begin extends number, End extends number, I extends number[] = []&gt; = End extends I[&quot;length&quot;] ? [I[&quot;length&quot;]] : IsLess&lt;I[&quot;length&quot;], Begin&gt; extends false ? Range&lt;Begin, End, [...I, 0]&gt; : [I[&quot;length&quot;], ...Range&lt;Begin, End, [...I, 0]&gt;] 增加&#x2F;减少修饰符Readonly、Partial 等 重载1234567function toString(x: string): string;function toString(x: number): string;// 实现签名（函数体具体实现）function toString(x: string | number) &#123; return String(x)&#125; 防御性编程123456789101112131415161718interface Foo &#123; type: &#x27;foo&#x27; &#125;interface Bar &#123; type: &#x27;bar&#x27; &#125;type All = Foo | Barfunction handleValue(val: All) &#123; switch (val.type) &#123; case &#x27;foo&#x27;: // 这里 val 被收窄为 Foo break case &#x27;bar&#x27;: // val 在这里是 Bar break default: // val 在这里是 never const exhaustiveCheck: never = val break &#125;&#125; 引用 重学 TS","categories":[],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://wuhongxing.github.io/tags/typescript/"}]},{"title":"clean code","slug":"clean-code","date":"2023-12-13T22:51:06.000Z","updated":"2023-12-13T23:35:28.000Z","comments":true,"path":"2023/12/14/clean-code/","permalink":"https://wuhongxing.github.io/2023/12/14/clean-code/","excerpt":"","text":"前言通常我们学习都是从一门语言开始，但是一旦脱离对应的语言及平台，我们所学的知识可能没有任何用武之地。 而 clean code 是一个通用的技术，除了需要极少量的语言特性。而且这种越底层越通用的技术学会了，能够极大的提升内功，日常迭代过程中的增强我们代码的可维护性，可以帮助我们可以毫不费力的就可以写出质量非常高的代码。 而我们日常做 code review 时，这个也会是一个很大的指导原则。 怎么做？ 命名有意义（参数、方法名、常&#x2F;变量名） 尽量短 (类、函数名、函数体、参数) dry (意图、结构、代码) 保持一致性 命名 精准命名 不能过于宽泛 应该描述意图，而非细节 不要用技术术语命名 用业务语言写代码，建议团队的语汇库 常量、变量、类、字面量命名应该使用名词， 函数命名应该使用动词12345678910111213// 精准命名processChapter(id) =&gt; changeChapterToTranslating(id) =&gt; startTranslation(id)yyyymmdd =&gt; currentDateyyyymmddhhmmss =&gt; currentTime86400000 =&gt; MILLISECONDS_PER_DAYcityZipCodeRegex[1], cityZipCodeRegex[2] =&gt; [_, city, zipCode] = address.match(cityZipCodeRegex) || []// 不要用技术术语命名bookList / bookArray / bookSet =&gt; books 函数 不能有意图重复，只要意图不重复哪怕一模一样也是可以接受的 参数小于等于2个 函数行数小于20行 保证可测试性123verifyUsername() / verifyPassword()createElement(&#x27;div&#x27;, &#123;...props&#125;) 参数 remove flag argument 动静分离，如果一个参数他们的字段变化频率并不一致时，考虑拆分他们到不同的对象中 聚沙成塔：如果参数很多时，应该封装成对象。如果些对象还具有某些行为，封装成类1createFile(isTemp) =&gt; createFile() + createTempFile() 类 职责单一、尽量小（字段少、参数少） 字段分组 - 和参数的动静分离对应 控制语句 卫语句: 提前 return 判断条件重复时可以状态模式&#x2F;策略模式(可以使用表单法来构造) - 开闭原则的体现12345678if (xxx) &#123;&#125; else &#123;&#125;=&gt;if (xxx) return xxxreturn xxx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function getPrice(type) &#123; switch(type) &#123; case .type1: return price * 0.8 case .type2: return price * 0.7 case .type3: return price * 0.6 &#125;&#125;function getEpubPrice() &#123; switch(type) &#123; case .type1: return price * 0.85 case .type2: return price * 0.75 case .type3: return price * 0.65 &#125;&#125;=&gt;interface Type &#123; getPrice() getEpubPrice()&#125;class Type1 implements Type &#123; getPrice() getEpubPrice()&#125;class Type2 implements Type &#123; getPrice() getEpubPrice()&#125;class Type3 implements Type &#123; getPrice() getEpubPrice()&#125;switch(type) &#123; case .type1: return new Type1() case .type2: return new Type2() case .type3: return new Type3()&#125;// 或者使用表单法&#123;type1: new Type1(), type2: new Type2(), type3: new Type3()&#125;[type]function getPrice() &#123; return type.getPrice()&#125;function getEpubPrice() &#123; return type.getEpubPrice()&#125; 封装 避免火车残骸代码（迪米特法则&#x2F;最少知道原则的体现） 基本类型偏执（这个可以使用 ts 解决） 一次性完成变量的初始化 增加防腐层，主要在于判断是不是有可能被替换。 比如我完成一些功能后将其发送到钉钉，但是这个完全可能被替换，那么这个时候，我们是不能在业务直接调用，而应该增加防腐层。（依赖倒置原则的体现 - 高层不应该依赖低层，二者都应该依赖抽象。抽象不依赖于细节，细节应该依赖于抽象。） 12345678910111213141516171819202122232425262728293031323334a.b.c.d =&gt; a.bbnumber =&gt; type Money = numberlet value = &#x27;&#x27;if (xxx) value = xxxelse value = xxx=&gt;getValue() &#123; if (xxx) return xxx return xxx&#125;class Test &#123; feishuService sendBook() &#123; try &#123;&#125; catch(error) &#123; feishuService.send(error) &#125; &#125;&#125;=&gt;interface FailureService &#123; send(error)&#125;class FeishuService implements FailureService &#123;&#125;class Test &#123; failureService: FailureService sendBook() &#123; try &#123;&#125; catch(error) &#123; failureService.send(error) &#125; &#125;&#125; 引用 clean-code-javascript 极客时间《代码之丑》","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://wuhongxing.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"clean code","slug":"clean-code","permalink":"https://wuhongxing.github.io/tags/clean-code/"}]},{"title":"solid","slug":"design-patterns-solid","date":"2023-12-13T22:51:06.000Z","updated":"2023-12-15T09:59:44.000Z","comments":true,"path":"2023/12/14/design-patterns-solid/","permalink":"https://wuhongxing.github.io/2023/12/14/design-patterns-solid/","excerpt":"","text":"前言 设计模式的六大原则，就像武侠小说中的内功。只有真正深厚的内功，使用出的招式才能威力无比。 而 23 种设计模式，就是武功招式。要练到出神入化，形成肌肉记忆，后续就可不拘泥于具体形式，达到无招胜有招的地步。 当看过几遍设计模式之后，就发现很多 UML 类图甚至是完全一致的，区分他们的关键就在于意图。只要你的意图不一致，哪怕代码完全一样，也是不同的设计模式。 谨记：所有的设计模式都会增加系统复杂度，所以可以不用，但是不能不会。 单一职责模式最重要但是也最难以说清的模式。最粗暴的理解就是要短小，无论是方法、类。 如何理解业务，应该将其拆分和聚合到什么程度。 如何判断变化的维度，如果是在 A 维度变化，你在 B 维度增加了扩展性，就是过度设计。 以上两点需要结合过往的经验以及当前的业务，这些持之以恒的积累才是进阶真正的不二法门。 BAD: 123456789101112131415class UserSettings &#123; constructor(user) &#123; this.user = user; &#125; changeSettings(settings) &#123; if (this.verifyCredentials()) &#123; // ... &#125; &#125; verifyCredentials() &#123; // ... &#125;&#125; GOOD: 12345678910111213141516171819202122class UserAuth &#123; constructor(user) &#123; this.user = user; &#125; verifyCredentials() &#123; // ... &#125;&#125;class UserSettings &#123; constructor(user) &#123; this.user = user; this.auth = new UserAuth(user); &#125; changeSettings(settings) &#123; if (this.auth.verifyCredentials()) &#123; // ... &#125; &#125;&#125; 上面的代码很简单明了的说明了单一模式应该怎么做。 但有一个问题就是我的这个类真的只有上面这几行代码，那么我将其拆出是不是徒增复杂度呢？ 开闭原则23 种设计模式绝大部分都是为了这个原则服务。问题的关键还是找到变化。 分层：将我们真正想完成的事情的流程抽象出来，将其中可能发生的变化，交给外部控制，这样就可以避免改动底层代码 BAD: 123456789101112131415161718192021222324252627282930313233343536373839class AjaxAdapter extends Adapter &#123; constructor() &#123; super(); this.name = &quot;ajaxAdapter&quot;; &#125;&#125;class NodeAdapter extends Adapter &#123; constructor() &#123; super(); this.name = &quot;nodeAdapter&quot;; &#125;&#125;class HttpRequester &#123; constructor(adapter) &#123; this.adapter = adapter; &#125; fetch(url) &#123; if (this.adapter.name === &quot;ajaxAdapter&quot;) &#123; return makeAjaxCall(url).then(response =&gt; &#123; // transform response and return &#125;); &#125; else if (this.adapter.name === &quot;nodeAdapter&quot;) &#123; return makeHttpCall(url).then(response =&gt; &#123; // transform response and return &#125;); &#125; &#125;&#125;function makeAjaxCall(url) &#123; // request and return promise&#125;function makeHttpCall(url) &#123; // request and return promise&#125; GOOD: 123456789101112131415161718192021222324252627282930313233class AjaxAdapter extends Adapter &#123; constructor() &#123; super(); this.name = &quot;ajaxAdapter&quot;; &#125; request(url) &#123; // request and return promise &#125;&#125;class NodeAdapter extends Adapter &#123; constructor() &#123; super(); this.name = &quot;nodeAdapter&quot;; &#125; request(url) &#123; // request and return promise &#125;&#125;class HttpRequester &#123; constructor(adapter) &#123; this.adapter = adapter; &#125; fetch(url) &#123; return this.adapter.request(url).then(response =&gt; &#123; // transform response and return &#125;); &#125;&#125; 上述终极目的是通过网络获取数据。而不同的平台可能会有不同的请求方式，他就是变化的点，我们就需要将其抽象出来。 上述代码有一个问题就在于每个调用 HttpRequester 的地方都得 new Adapter()，我们可以通过工厂模式来解决这个问题。 里氏替换原则这条规则是我们在使用继承时应当遵守的。 子类永远不能修改父类的行为，只可以增强。也就是将所有的子类，替换为父类并不会对程序的结果造成影响。 BAD: 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950class Rectangle &#123; constructor() &#123; this.width = 0; this.height = 0; &#125; setColor(color) &#123; // ... &#125; render(area) &#123; // ... &#125; setWidth(width) &#123; this.width = width; &#125; setHeight(height) &#123; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125;&#125;class Square extends Rectangle &#123; setWidth(width) &#123; this.width = width; this.height = width; &#125; setHeight(height) &#123; this.width = height; this.height = height; &#125;&#125;function renderLargeRectangles(rectangles) &#123; rectangles.forEach(rectangle =&gt; &#123; rectangle.setWidth(4); rectangle.setHeight(5); const area = rectangle.getArea(); // BAD: Returns 25 for Square. Should be 20. rectangle.render(area); &#125;);&#125;const rectangles = [new Rectangle(), new Rectangle(), new Square()];renderLargeRectangles(rectangles); GOOD: 123456789101112131415161718192021222324252627282930313233343536373839404142class Shape &#123; setColor(color) &#123; // ... &#125; render(area) &#123; // ... &#125;&#125;class Rectangle extends Shape &#123; constructor(width, height) &#123; super(); this.width = width; this.height = height; &#125; getArea() &#123; return this.width * this.height; &#125;&#125;class Square extends Shape &#123; constructor(length) &#123; super(); this.length = length; &#125; getArea() &#123; return this.length * this.length; &#125;&#125;function renderLargeShapes(shapes) &#123; shapes.forEach(shape =&gt; &#123; const area = shape.getArea(); shape.render(area); &#125;);&#125;const shapes = [new Rectangle(4, 5), new Rectangle(4, 5), new Square(5)];renderLargeShapes(shapes); 接口隔离原则可以理解为接口的单一职责原则。 Bad: 123456789101112131415161718192021class DOMTraverser &#123; constructor(settings) &#123; this.settings = settings; this.setup(); &#125; setup() &#123; this.rootNode = this.settings.rootNode; this.settings.animationModule.setup(); &#125; traverse() &#123; // ... &#125;&#125;const $ = new DOMTraverser(&#123; rootNode: document.getElementsByTagName(&quot;body&quot;), animationModule() &#123;&#125; // Most of the time, we won&#x27;t need to animate when traversing. // ...&#125;); GOOD: 1234567891011121314151617181920212223242526272829class DOMTraverser &#123; constructor(settings) &#123; this.settings = settings; this.options = settings.options; this.setup(); &#125; setup() &#123; this.rootNode = this.settings.rootNode; this.setupOptions(); &#125; setupOptions() &#123; if (this.options.animationModule) &#123; // ... &#125; &#125; traverse() &#123; // ... &#125;&#125;const $ = new DOMTraverser(&#123; rootNode: document.getElementsByTagName(&quot;body&quot;), options: &#123; animationModule() &#123;&#125; &#125;&#125;); 依赖倒置原则简单来说，A 类依赖实现了 IB 接口的类 B，那么这个时候应该由外部传入，而不应该直接在内部直接初始化一个。而如果初始化一个默认值，则是允许的。 12345678910111213141516171819202122232425262728class InventoryRequester &#123; constructor() &#123; this.REQ_METHODS = [&quot;HTTP&quot;]; &#125; requestItem(item) &#123; // ... &#125;&#125;class InventoryTracker &#123; constructor(items) &#123; this.items = items; // BAD: We have created a dependency on a specific request implementation. // We should just have requestItems depend on a request method: `request` this.requester = new InventoryRequester(); &#125; requestItems() &#123; this.items.forEach(item =&gt; &#123; this.requester.requestItem(item); &#125;); &#125;&#125;const inventoryTracker = new InventoryTracker([&quot;apples&quot;, &quot;bananas&quot;]);inventoryTracker.requestItems(); GOOD: 12345678910111213141516171819202122232425262728293031323334353637383940class InventoryTracker &#123; constructor(items, requester) &#123; this.items = items; this.requester = requester; &#125; requestItems() &#123; this.items.forEach(item =&gt; &#123; this.requester.requestItem(item); &#125;); &#125;&#125;class InventoryRequesterV1 &#123; constructor() &#123; this.REQ_METHODS = [&quot;HTTP&quot;]; &#125; requestItem(item) &#123; // ... &#125;&#125;class InventoryRequesterV2 &#123; constructor() &#123; this.REQ_METHODS = [&quot;WS&quot;]; &#125; requestItem(item) &#123; // ... &#125;&#125;// By constructing our dependencies externally and injecting them, we can easily// substitute our request module for a fancy new one that uses WebSockets.const inventoryTracker = new InventoryTracker( [&quot;apples&quot;, &quot;bananas&quot;], new InventoryRequesterV2());inventoryTracker.requestItems(); 迪米特法则&#x2F;最小知道原则就是要把内部的复杂度隐藏起来，对外部只提供需要的接口。火车残骸代码就是典型的错误。设计模式中的门面模式就是他的最佳实践。","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://wuhongxing.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"solid","slug":"solid","permalink":"https://wuhongxing.github.io/tags/solid/"}]},{"title":"mini-promise","slug":"mini-promise","date":"2023-12-04T15:29:53.000Z","updated":"2023-12-04T15:29:53.000Z","comments":true,"path":"2023/12/04/mini-promise/","permalink":"https://wuhongxing.github.io/2023/12/04/mini-promise/","excerpt":"","text":"constructor promise 有三种状态，pending、fulfilled、rejected，默认为 pending 传入的函数立即执行12345678910111213141516171819202122232425class Promise &#123; constructor(executor) &#123; this.status = &#x27;pending&#x27;; this.value = undefined; this.fulfilledCallbacks = []; this.rejectedCallbacks = []; const resolve = (value) =&gt; &#123; if (status !== &#x27;pending&#x27;) return; // 这里要将值保存的原因在于 promise 被创建来之后，还没有 then，当 then 被调用的时候，能取到对应的值 this.value = value // 当 then 被绑定时，promise 仍然处于 pending 状态，当 fulfilled 之后需要执行 then this.fulfilledCallbacks.forEach(fn =&gt; fn()) this.status = &#x27;fulfilled&#x27; &#125; const reject = (reason) =&gt; &#123; if (status!== &#x27;pending&#x27;) return; this.value = reason this.rejectedCallbacks.forEach(fn =&gt; fn()) this.status =&#x27;rejected&#x27; &#125; executor(resolve, reject); &#125;&#125; then 由于 then 支持链式调用，所以我们要生成一个新的 promise 执行 onFulfilled&#x2F;onRejected 时不可以和新的 promise 在同一个上下文 onFulfilled&#x2F;onRejected 的返回值可能是一个 promise，需要将 promise 的值返回 onFulfilled&#x2F;onRejected 是可能出错的，所以需要捕获错误 onFulfilled&#x2F;onRejected 是可选的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110function resolvePromise(promise, x, resolve, reject) &#123; // 如果返回的 promise 和 x 是同一个 if (promise === x) &#123; return reject(new TypeError(&quot;Chaining cycle detected for promise&quot;)) &#125; else if ((typeof x === &quot;object&quot; &amp;&amp; x !== null) || typeof x === &quot;function&quot;) &#123; // 保证不会被多次执行 let called = false try &#123; const then = x.then if (typeof then === &quot;function&quot;) &#123; then.call( x, y =&gt; &#123; if (called) return called = true /* 处理嵌套的 promise new Promise(resolve =&gt; &#123; return new Promise(resolve =&gt; &#123; return new Promise(resolve =&gt; &#123; resolve(1) &#125;) &#125;) &#125;) */ resolvePromise(x, y, resolve, reject) &#125;, r =&gt; &#123; if (called) return called = true reject(r) &#125; ) &#125; else &#123; if (called) return called = true resolve(x) &#125; &#125; catch (error) &#123; if (called) return called = true reject(error) &#125; &#125; else &#123; resolve(x) &#125;&#125;// 模拟微任务function runMicroTask(fn) &#123; if (typeof global.nextTick === &quot;function&quot;) &#123; global.nextTick(fn) &#125; else if (typeof MutationObserver === &quot;function&quot;) &#123; const help = document.createElement(&quot;div&quot;) const ob = new MutationObserver(fn) ob.observe(help, &#123; attributes: true &#125;) // Trigger the observer by modifying the attributes of the div. help.setAttribute(&quot;data-mutation-observer&quot;, &quot;trigger&quot;) &#125; else &#123; setTimeout(fn, 0) &#125;&#125;class Promise&#123; then(onfulfilled, onrejected) &#123; onfulfilled = typeof onfulfilled === &quot;function&quot; ? onfulfilled : value =&gt; value onrejected = typeof onrejected === &quot;function&quot; ? onrejected : reason =&gt; &#123; throw reason &#125; const promise = new Promise((resolve, reject) =&gt; &#123; const handleFulfilled = () =&gt; &#123; // 不可以放到同一上下文中，不然的话 promise 也无法读取到 runMicroTask(() =&gt; &#123; try &#123; const x = onfulfilled(this.value) resolvePromise(promise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; const handleRejected = () =&gt; &#123; runMicroTask(() =&gt; &#123; try &#123; const x = onrejected(this.reason) resolvePromise(promise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; if (this.status === FULFILLED) &#123; handleFulfilled() &#125; if (this.status === REJECTED) &#123; handleRejected() &#125; if (this.status === PENDING) &#123; this.onFulfilledCallbacks.push(handleFulfilled) this.onRejectedCallbacks.push(handleRejected) &#125; &#125;) return promise &#125;&#125; finally无论成功或者失败都会执行 12345678class Promise &#123; finally(callback) &#123; return this.then( value =&gt; Promise.resolve(callback()).then(() =&gt; value), reason =&gt; Promise.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) ) &#125;&#125; all 返回一个新的 promise 将所有的结果都保存在 result 中，当 index === values.length 时，resolve(result) 123456789101112131415161718192021222324Promise.all = function (values) &#123; return new Promise((resolve, reject) =&gt; &#123; const result = [] let index = 0 function processData(key, value) &#123; result[key] = value index += 1 if (values.length === index) &#123; resolve(result) &#125; &#125; for (let i = 0; i &lt; values.length; i++) &#123; let current = values[i] if (isPromise(current)) &#123; current.then(value =&gt; &#123; processData(i, value) &#125;, reject) &#125; else &#123; processData(i, current) &#125; &#125; &#125;)&#125; resolve 如果是普通值，需要将其转化为 promise，后续的才能调用 then1234Promise.resolve = value =&gt; &#123; if (isPromise(value)) return value return new Promise(resolve =&gt; resolve(value))&#125; generator1234567891011const obj = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, *[Symbol.iterator]() &#123; for (let i = 0; i &lt; this.length; i++) &#123; yield this[i] &#125; &#125;&#125; 123456789101112131415161718192021222324252627function* read() &#123; const a = yield &quot;hello&quot; console.log(a) const b = yield &quot;world&quot; console.log(b) return 10&#125;function co(it) &#123; // 循环没有办法异步，递归是可以的 return new Promise((resolve, reject) =&gt; &#123; const next = r =&gt; &#123; const &#123; value, done &#125; = it.next(r) if (done) &#123; resolve(value) &#125; else &#123; Promise.resolve(value).then(res =&gt; &#123; next(res) &#125;, reject) &#125; &#125; next() &#125;)&#125;co(read()).then(res =&gt; &#123; console.log(res)&#125;)","categories":[{"name":"mini","slug":"mini","permalink":"https://wuhongxing.github.io/categories/mini/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://wuhongxing.github.io/tags/promise/"}]},{"title":"使用 Hexo 搭建博客","slug":"build-blog-with-hexo","date":"2023-11-30T01:38:39.000Z","updated":"2023-11-30T01:38:39.000Z","comments":true,"path":"2023/11/30/build-blog-with-hexo/","permalink":"https://wuhongxing.github.io/2023/11/30/build-blog-with-hexo/","excerpt":"","text":"前置准备node 环境、github 账号、VPN 开始 安装 hexo-cli 1npm install -g hexo-cli 生成 blog 123hexo init blogcd blognpm install 部署3.1 申请一个新的 git 仓库：https://github.com/wuhongxing/wuhongxing.github.io 3.2 重写 _config.yml 中的 deploy 配置 12345deploy: type: git repo: https://github.com/wuhongxing/wuhongxing.github.io.git branch: main message: 初次提交 3.3 安装插件 1npm install hexo-deployer-git --save 3.4 执行 yarn clean &amp; yarn deploy 即可然后就可以打开 wuhongxing.github.io 就可以看见我们的博客了。 开始写作 执行 yarn server，启动一个本地服务，打开页面后，保存更改的内容就能实时看到 创建新的文章或者页面，可以使用下面的命令，也可以手动 123hexo new [layout] &lt;title&gt;# exhexo new post &#x27;test&#x27; 主题、插件 可以到 https://hexo.io/themes/ 上面挑一个自己喜欢的 安装主题 2.1 git clone 到 theme 文件夹中 2.2 安装依赖 12345npm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 2.3 在 theme/pure/_config.yml 中开启 1234567busuanzi: enable: true # 不蒜子统计postCount: enable: true # 是否开启文章字数统计 wordcount: true # 文章字数统计 min2read: true 将 blog/_config.yml 中的 theme 字段改为你刚才的主题名称 最后执行 yarn server 就可以看到效果了 参考 零花费白嫖：免费利用Hexo和GitHub打造个人博客 官方文档 pure","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wuhongxing.github.io/tags/hexo/"}]},{"title":"模板引擎","slug":"template-engine","date":"2023-11-29T22:51:06.000Z","updated":"2023-12-03T09:36:25.000Z","comments":true,"path":"2023/11/30/template-engine/","permalink":"https://wuhongxing.github.io/2023/11/30/template-engine/","excerpt":"","text":"什么是模板引擎模板引擎是一种用于生成 HTML 页面的工具，它可以将数据插入到 HTML 页面中，从而生成完整的 HTML 页面。 实现一个 mini-ejs前置准备 如何执行一段字符串中的 JavaScript 代码？ 方案一: 使用 eval() 12const str = console.log(&#x27;hello world&#x27;)eval(str) 方案二: 使用 new Function() 123const str = &#x27;console.log(&quot;hello world&quot;)&#x27;const fn = new Function(str)fn() 如何传递参数？ 123const str = &#x27;console.log(&quot;hello world&quot;, a, b)&#x27;const fun = new Function(&quot;a&quot;, &quot;b&quot;, str)fun(1, 2) 优化: 封装成对象传递 123const str = &#x27;console.log(&quot;hello world&quot;, obj.a, obj.b)&#x27;const fun = new Function(&quot;obj&quot;, str)fun(&#123; a: 1, b: 2 &#125;) 再优化: 使用 with 语句 123const str = &#x27;with(obj) &#123;console.log(&quot;hello world&quot;, a, b)&#125;&#x27;const fun = new Function(&quot;obj&quot;, str)fun(&#123; a: 1, b: 2 &#125;) 开始实现这个是 ejs 中的内容 12345&#123;% if (isShow) &#123; %&#125;&lt;div&gt;&#123;%= name %&#125;&lt;/div&gt;&#123;% &#125; else &#123; %&#125;&lt;div&gt;age: &#123;%= age %&#125;&lt;/div&gt;&#123;% &#125; %&#125; 解析变量 123456// 将 &#123;%= 解析为 $&#123;，将 %&#125; 解析为 &#125;// `&lt;div&gt;&#123;%= name %&#125;&lt;/div&gt;` =&gt; `&lt;div&gt;$&#123;name&#125;&lt;/div&gt;`let temp = &quot;with(obj) &#123; return `&quot; + content.replace(/\\&#123;\\%\\=([^\\&#125;]+)\\%\\&#125;/g, ($0, $1) =&gt; `\\$\\&#123;$&#123;$1.trim()&#125;\\&#125;`) + &quot;`&#125;&quot; 剥离其中的 js 语句 123456789101112131415161718// 将 %&#123; 变为 `，将 %&#125; 变为 str += `with(obj) &#123; return `&#123;% if (isShow) &#123; %&#125;&lt;div&gt;$&#123;name&#125;&lt;/div&gt;&#123;% &#125; else &#123; %&#125;&lt;div&gt;age: $&#123;age&#125;&lt;/div&gt;&#123;% &#125; %&#125;`&#125;// 就可以转化为下面的结构let str = &#x27;&#x27;with(obj) &#123; return str += ``if (isShow) &#123; str += `&lt;div&gt;$&#123;name&#125;&lt;/div&gt;`&#125; else &#123; str += `&lt;div&gt;age: $&#123;age&#125;&lt;/div&gt;`&#125; str += ``&#125;return str 12345let temp = &quot;let str = &#x27;&#x27;; with(obj) &#123; str += `&quot; + content.replace(/\\&#123;\\%\\=([^\\&#125;]+)\\%\\&#125;/g, ($0, $1) =&gt; `\\$\\&#123;$&#123;$1.trim()&#125;\\&#125;`) + &quot;`&#125; return str&quot;temp = temp.replace(/\\&#123;\\%([^\\%]+)\\%\\&#125;/g, ($0, $1) =&gt; `\\`\\n$&#123;$1&#125;str+=\\``) 构建函数并执行123456789const build = (template, data) =&gt; &#123; const fn = new Function(&quot;obj&quot;, template) return fn(data)&#125;const res = build(temp, &#123; name: &quot;whx111&quot;, age: &quot;100&quot;, isShow: true&#125;) 完整代码 安全性EJS 实际上是一个 JavaScript 运行时。它的全部工作是执行 JavaScript。如果您运行 EJS 渲染方法而不检查你自己投入，你对结果负责。 简而言之，请勿提交包含以下代码片段的“漏洞”： 123app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.render(&#x27;index&#x27;, req.query);&#125;); 参考SECURITY.md模板引擎是什么？","categories":[{"name":"mini","slug":"mini","permalink":"https://wuhongxing.github.io/categories/mini/"}],"tags":[{"name":"模板引擎","slug":"模板引擎","permalink":"https://wuhongxing.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"}]}],"categories":[{"name":"日常记录","slug":"日常记录","permalink":"https://wuhongxing.github.io/categories/%E6%97%A5%E5%B8%B8%E8%AE%B0%E5%BD%95/"},{"name":"设计模式","slug":"设计模式","permalink":"https://wuhongxing.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"},{"name":"mini","slug":"mini","permalink":"https://wuhongxing.github.io/categories/mini/"}],"tags":[{"name":"typescript","slug":"typescript","permalink":"https://wuhongxing.github.io/tags/typescript/"},{"name":"clean code","slug":"clean-code","permalink":"https://wuhongxing.github.io/tags/clean-code/"},{"name":"solid","slug":"solid","permalink":"https://wuhongxing.github.io/tags/solid/"},{"name":"promise","slug":"promise","permalink":"https://wuhongxing.github.io/tags/promise/"},{"name":"hexo","slug":"hexo","permalink":"https://wuhongxing.github.io/tags/hexo/"},{"name":"模板引擎","slug":"模板引擎","permalink":"https://wuhongxing.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"}]}