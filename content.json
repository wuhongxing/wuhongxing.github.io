{"meta":{"title":"Hexo","subtitle":"","description":"","author":"吴红星","url":"https://wuhongxing.github.io","root":"/"},"pages":[],"posts":[{"title":"mini-promise","slug":"mini-promise","date":"2023-12-03T08:57:11.951Z","updated":"2023-12-04T15:29:53.285Z","comments":true,"path":"2023/12/03/mini-promise/","permalink":"https://wuhongxing.github.io/2023/12/03/mini-promise/","excerpt":"","text":"constructor promise 有三种状态，pending、fulfilled、rejected，默认为 pending 传入的函数立即执行12345678910111213141516171819202122232425class Promise &#123; constructor(executor) &#123; this.status = &#x27;pending&#x27;; this.value = undefined; this.fulfilledCallbacks = []; this.rejectedCallbacks = []; const resolve = (value) =&gt; &#123; if (status !== &#x27;pending&#x27;) return; // 这里要将值保存的原因在于 promise 被创建来之后，还没有 then，当 then 被调用的时候，能取到对应的值 this.value = value // 当 then 被绑定时，promise 仍然处于 pending 状态，当 fulfilled 之后需要执行 then this.fulfilledCallbacks.forEach(fn =&gt; fn()) this.status = &#x27;fulfilled&#x27; &#125; const reject = (reason) =&gt; &#123; if (status!== &#x27;pending&#x27;) return; this.value = reason this.rejectedCallbacks.forEach(fn =&gt; fn()) this.status =&#x27;rejected&#x27; &#125; executor(resolve, reject); &#125;&#125; then 由于 then 支持链式调用，所以我们要生成一个新的 promise 执行 onFulfilled&#x2F;onRejected 时不可以和新的 promise 在同一个上下文 onFulfilled&#x2F;onRejected 的返回值可能是一个 promise，需要将 promise 的值返回 onFulfilled&#x2F;onRejected 是可能出错的，所以需要捕获错误 onFulfilled&#x2F;onRejected 是可选的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110function resolvePromise(promise, x, resolve, reject) &#123; // 如果返回的 promise 和 x 是同一个 if (promise === x) &#123; return reject(new TypeError(&quot;Chaining cycle detected for promise&quot;)) &#125; else if ((typeof x === &quot;object&quot; &amp;&amp; x !== null) || typeof x === &quot;function&quot;) &#123; // 保证不会被多次执行 let called = false try &#123; const then = x.then if (typeof then === &quot;function&quot;) &#123; then.call( x, y =&gt; &#123; if (called) return called = true /* 处理嵌套的 promise new Promise(resolve =&gt; &#123; return new Promise(resolve =&gt; &#123; return new Promise(resolve =&gt; &#123; resolve(1) &#125;) &#125;) &#125;) */ resolvePromise(x, y, resolve, reject) &#125;, r =&gt; &#123; if (called) return called = true reject(r) &#125; ) &#125; else &#123; if (called) return called = true resolve(x) &#125; &#125; catch (error) &#123; if (called) return called = true reject(error) &#125; &#125; else &#123; resolve(x) &#125;&#125;// 模拟微任务function runMicroTask(fn) &#123; if (typeof global.nextTick === &quot;function&quot;) &#123; global.nextTick(fn) &#125; else if (typeof MutationObserver === &quot;function&quot;) &#123; const help = document.createElement(&quot;div&quot;) const ob = new MutationObserver(fn) ob.observe(help, &#123; attributes: true &#125;) // Trigger the observer by modifying the attributes of the div. help.setAttribute(&quot;data-mutation-observer&quot;, &quot;trigger&quot;) &#125; else &#123; setTimeout(fn, 0) &#125;&#125;class Promise&#123; then(onfulfilled, onrejected) &#123; onfulfilled = typeof onfulfilled === &quot;function&quot; ? onfulfilled : value =&gt; value onrejected = typeof onrejected === &quot;function&quot; ? onrejected : reason =&gt; &#123; throw reason &#125; const promise = new Promise((resolve, reject) =&gt; &#123; const handleFulfilled = () =&gt; &#123; // 不可以放到同一上下文中，不然的话 promise 也无法读取到 runMicroTask(() =&gt; &#123; try &#123; const x = onfulfilled(this.value) resolvePromise(promise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; const handleRejected = () =&gt; &#123; runMicroTask(() =&gt; &#123; try &#123; const x = onrejected(this.reason) resolvePromise(promise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; if (this.status === FULFILLED) &#123; handleFulfilled() &#125; if (this.status === REJECTED) &#123; handleRejected() &#125; if (this.status === PENDING) &#123; this.onFulfilledCallbacks.push(handleFulfilled) this.onRejectedCallbacks.push(handleRejected) &#125; &#125;) return promise &#125;&#125; finally无论成功或者失败都会执行 12345678class Promise &#123; finally(callback) &#123; return this.then( value =&gt; Promise.resolve(callback()).then(() =&gt; value), reason =&gt; Promise.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) ) &#125;&#125; all 返回一个新的 promise 将所有的结果都保存在 result 中，当 index === values.length 时，resolve(result) 123456789101112131415161718192021222324Promise.all = function (values) &#123; return new Promise((resolve, reject) =&gt; &#123; const result = [] let index = 0 function processData(key, value) &#123; result[key] = value index += 1 if (values.length === index) &#123; resolve(result) &#125; &#125; for (let i = 0; i &lt; values.length; i++) &#123; let current = values[i] if (isPromise(current)) &#123; current.then(value =&gt; &#123; processData(i, value) &#125;, reject) &#125; else &#123; processData(i, current) &#125; &#125; &#125;)&#125; resolve 如果是普通值，需要将其转化为 promise，后续的才能调用 then1234Promise.resolve = value =&gt; &#123; if (isPromise(value)) return value return new Promise(resolve =&gt; resolve(value))&#125; generator1234567891011const obj = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, *[Symbol.iterator]() &#123; for (let i = 0; i &lt; this.length; i++) &#123; yield this[i] &#125; &#125;&#125; 123456789101112131415161718192021222324252627function* read() &#123; const a = yield &quot;hello&quot; console.log(a) const b = yield &quot;world&quot; console.log(b) return 10&#125;function co(it) &#123; // 循环没有办法异步，递归是可以的 return new Promise((resolve, reject) =&gt; &#123; const next = r =&gt; &#123; const &#123; value, done &#125; = it.next(r) if (done) &#123; resolve(value) &#125; else &#123; Promise.resolve(value).then(res =&gt; &#123; next(res) &#125;, reject) &#125; &#125; next() &#125;)&#125;co(read()).then(res =&gt; &#123; console.log(res)&#125;)","categories":[{"name":"mini","slug":"mini","permalink":"https://wuhongxing.github.io/categories/mini/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://wuhongxing.github.io/tags/promise/"}]},{"title":"模板引擎","slug":"template-engine","date":"2023-11-29T22:51:06.000Z","updated":"2023-12-03T09:36:25.330Z","comments":true,"path":"2023/11/30/template-engine/","permalink":"https://wuhongxing.github.io/2023/11/30/template-engine/","excerpt":"","text":"什么是模板引擎模板引擎是一种用于生成 HTML 页面的工具，它可以将数据插入到 HTML 页面中，从而生成完整的 HTML 页面。 实现一个 mini-ejs前置准备 如何执行一段字符串中的 JavaScript 代码？ 方案一: 使用 eval() 12const str = console.log(&#x27;hello world&#x27;)eval(str) 方案二: 使用 new Function() 123const str = &#x27;console.log(&quot;hello world&quot;)&#x27;const fn = new Function(str)fn() 如何传递参数？ 123const str = &#x27;console.log(&quot;hello world&quot;, a, b)&#x27;const fun = new Function(&quot;a&quot;, &quot;b&quot;, str)fun(1, 2) 优化: 封装成对象传递 123const str = &#x27;console.log(&quot;hello world&quot;, obj.a, obj.b)&#x27;const fun = new Function(&quot;obj&quot;, str)fun(&#123; a: 1, b: 2 &#125;) 再优化: 使用 with 语句 123const str = &#x27;with(obj) &#123;console.log(&quot;hello world&quot;, a, b)&#125;&#x27;const fun = new Function(&quot;obj&quot;, str)fun(&#123; a: 1, b: 2 &#125;) 开始实现这个是 ejs 中的内容 12345&#123;% if (isShow) &#123; %&#125;&lt;div&gt;&#123;%= name %&#125;&lt;/div&gt;&#123;% &#125; else &#123; %&#125;&lt;div&gt;age: &#123;%= age %&#125;&lt;/div&gt;&#123;% &#125; %&#125; 解析变量 123456// 将 &#123;%= 解析为 $&#123;，将 %&#125; 解析为 &#125;// `&lt;div&gt;&#123;%= name %&#125;&lt;/div&gt;` =&gt; `&lt;div&gt;$&#123;name&#125;&lt;/div&gt;`let temp = &quot;with(obj) &#123; return `&quot; + content.replace(/\\&#123;\\%\\=([^\\&#125;]+)\\%\\&#125;/g, ($0, $1) =&gt; `\\$\\&#123;$&#123;$1.trim()&#125;\\&#125;`) + &quot;`&#125;&quot; 剥离其中的 js 语句 123456789101112131415161718// 将 %&#123; 变为 `，将 %&#125; 变为 str += `with(obj) &#123; return `&#123;% if (isShow) &#123; %&#125;&lt;div&gt;$&#123;name&#125;&lt;/div&gt;&#123;% &#125; else &#123; %&#125;&lt;div&gt;age: $&#123;age&#125;&lt;/div&gt;&#123;% &#125; %&#125;`&#125;// 就可以转化为下面的结构let str = &#x27;&#x27;with(obj) &#123; return str += ``if (isShow) &#123; str += `&lt;div&gt;$&#123;name&#125;&lt;/div&gt;`&#125; else &#123; str += `&lt;div&gt;age: $&#123;age&#125;&lt;/div&gt;`&#125; str += ``&#125;return str 12345let temp = &quot;let str = &#x27;&#x27;; with(obj) &#123; str += `&quot; + content.replace(/\\&#123;\\%\\=([^\\&#125;]+)\\%\\&#125;/g, ($0, $1) =&gt; `\\$\\&#123;$&#123;$1.trim()&#125;\\&#125;`) + &quot;`&#125; return str&quot;temp = temp.replace(/\\&#123;\\%([^\\%]+)\\%\\&#125;/g, ($0, $1) =&gt; `\\`\\n$&#123;$1&#125;str+=\\``) 构建函数并执行123456789const build = (template, data) =&gt; &#123; const fn = new Function(&quot;obj&quot;, template) return fn(data)&#125;const res = build(temp, &#123; name: &quot;whx111&quot;, age: &quot;100&quot;, isShow: true&#125;) 完整代码 安全性EJS 实际上是一个 JavaScript 运行时。它的全部工作是执行 JavaScript。如果您运行 EJS 渲染方法而不检查你自己投入，你对结果负责。 简而言之，请勿提交包含以下代码片段的“漏洞”： 123app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.render(&#x27;index&#x27;, req.query);&#125;); 参考SECURITY.md模板引擎是什么？","categories":[{"name":"mini","slug":"mini","permalink":"https://wuhongxing.github.io/categories/mini/"}],"tags":[{"name":"模板引擎","slug":"模板引擎","permalink":"https://wuhongxing.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"}]},{"title":"使用 Hexo 搭建博客","slug":"build-blog-with-hexo","date":"2023-11-28T12:47:11.575Z","updated":"2023-11-30T01:38:39.001Z","comments":true,"path":"2023/11/28/build-blog-with-hexo/","permalink":"https://wuhongxing.github.io/2023/11/28/build-blog-with-hexo/","excerpt":"","text":"前置准备node 环境、github 账号、VPN 开始 安装 hexo-cli 1npm install -g hexo-cli 生成 blog 123hexo init blogcd blognpm install 部署3.1 申请一个新的 git 仓库：https://github.com/wuhongxing/wuhongxing.github.io 3.2 重写 _config.yml 中的 deploy 配置 12345deploy: type: git repo: https://github.com/wuhongxing/wuhongxing.github.io.git branch: main message: 初次提交 3.3 安装插件 1npm install hexo-deployer-git --save 3.4 执行 yarn clean &amp; yarn deploy 即可然后就可以打开 wuhongxing.github.io 就可以看见我们的博客了。 开始写作 执行 yarn server，启动一个本地服务，打开页面后，保存更改的内容就能实时看到 创建新的文章或者页面，可以使用下面的命令，也可以手动 123hexo new [layout] &lt;title&gt;# exhexo new post &#x27;test&#x27; 主题、插件 可以到 https://hexo.io/themes/ 上面挑一个自己喜欢的 安装主题 2.1 git clone 到 theme 文件夹中 2.2 安装依赖 12345npm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 2.3 在 theme/pure/_config.yml 中开启 1234567busuanzi: enable: true # 不蒜子统计postCount: enable: true # 是否开启文章字数统计 wordcount: true # 文章字数统计 min2read: true 将 blog/_config.yml 中的 theme 字段改为你刚才的主题名称 最后执行 yarn server 就可以看到效果了 参考 零花费白嫖：免费利用Hexo和GitHub打造个人博客 官方文档 pure","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wuhongxing.github.io/tags/hexo/"}]}],"categories":[{"name":"mini","slug":"mini","permalink":"https://wuhongxing.github.io/categories/mini/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://wuhongxing.github.io/tags/promise/"},{"name":"模板引擎","slug":"模板引擎","permalink":"https://wuhongxing.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"},{"name":"hexo","slug":"hexo","permalink":"https://wuhongxing.github.io/tags/hexo/"}]}