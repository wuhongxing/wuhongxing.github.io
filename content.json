{"meta":{"title":"Hexo","subtitle":"","description":"","author":"吴红星","url":"https://wuhongxing.github.io","root":"/"},"pages":[],"posts":[{"title":"mini-promise","slug":"mini-promise","date":"2023-12-03T08:57:11.951Z","updated":"2023-12-04T15:29:53.285Z","comments":true,"path":"2023/12/03/mini-promise/","permalink":"https://wuhongxing.github.io/2023/12/03/mini-promise/","excerpt":"","text":"constructor promise 有三种状态，pending、fulfilled、rejected，默认为 pending 传入的函数立即执行12345678910111213141516171819202122232425class Promise &#123; constructor(executor) &#123; this.status = &#x27;pending&#x27;; this.value = undefined; this.fulfilledCallbacks = []; this.rejectedCallbacks = []; const resolve = (value) =&gt; &#123; if (status !== &#x27;pending&#x27;) return; // 这里要将值保存的原因在于 promise 被创建来之后，还没有 then，当 then 被调用的时候，能取到对应的值 this.value = value // 当 then 被绑定时，promise 仍然处于 pending 状态，当 fulfilled 之后需要执行 then this.fulfilledCallbacks.forEach(fn =&gt; fn()) this.status = &#x27;fulfilled&#x27; &#125; const reject = (reason) =&gt; &#123; if (status!== &#x27;pending&#x27;) return; this.value = reason this.rejectedCallbacks.forEach(fn =&gt; fn()) this.status =&#x27;rejected&#x27; &#125; executor(resolve, reject); &#125;&#125; then 由于 then 支持链式调用，所以我们要生成一个新的 promise 执行 onFulfilled&#x2F;onRejected 时不可以和新的 promise 在同一个上下文 onFulfilled&#x2F;onRejected 的返回值可能是一个 promise，需要将 promise 的值返回 onFulfilled&#x2F;onRejected 是可能出错的，所以需要捕获错误 onFulfilled&#x2F;onRejected 是可选的 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110function resolvePromise(promise, x, resolve, reject) &#123; // 如果返回的 promise 和 x 是同一个 if (promise === x) &#123; return reject(new TypeError(&quot;Chaining cycle detected for promise&quot;)) &#125; else if ((typeof x === &quot;object&quot; &amp;&amp; x !== null) || typeof x === &quot;function&quot;) &#123; // 保证不会被多次执行 let called = false try &#123; const then = x.then if (typeof then === &quot;function&quot;) &#123; then.call( x, y =&gt; &#123; if (called) return called = true /* 处理嵌套的 promise new Promise(resolve =&gt; &#123; return new Promise(resolve =&gt; &#123; return new Promise(resolve =&gt; &#123; resolve(1) &#125;) &#125;) &#125;) */ resolvePromise(x, y, resolve, reject) &#125;, r =&gt; &#123; if (called) return called = true reject(r) &#125; ) &#125; else &#123; if (called) return called = true resolve(x) &#125; &#125; catch (error) &#123; if (called) return called = true reject(error) &#125; &#125; else &#123; resolve(x) &#125;&#125;// 模拟微任务function runMicroTask(fn) &#123; if (typeof global.nextTick === &quot;function&quot;) &#123; global.nextTick(fn) &#125; else if (typeof MutationObserver === &quot;function&quot;) &#123; const help = document.createElement(&quot;div&quot;) const ob = new MutationObserver(fn) ob.observe(help, &#123; attributes: true &#125;) // Trigger the observer by modifying the attributes of the div. help.setAttribute(&quot;data-mutation-observer&quot;, &quot;trigger&quot;) &#125; else &#123; setTimeout(fn, 0) &#125;&#125;class Promise&#123; then(onfulfilled, onrejected) &#123; onfulfilled = typeof onfulfilled === &quot;function&quot; ? onfulfilled : value =&gt; value onrejected = typeof onrejected === &quot;function&quot; ? onrejected : reason =&gt; &#123; throw reason &#125; const promise = new Promise((resolve, reject) =&gt; &#123; const handleFulfilled = () =&gt; &#123; // 不可以放到同一上下文中，不然的话 promise 也无法读取到 runMicroTask(() =&gt; &#123; try &#123; const x = onfulfilled(this.value) resolvePromise(promise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; const handleRejected = () =&gt; &#123; runMicroTask(() =&gt; &#123; try &#123; const x = onrejected(this.reason) resolvePromise(promise, x, resolve, reject) &#125; catch (error) &#123; reject(error) &#125; &#125;) &#125; if (this.status === FULFILLED) &#123; handleFulfilled() &#125; if (this.status === REJECTED) &#123; handleRejected() &#125; if (this.status === PENDING) &#123; this.onFulfilledCallbacks.push(handleFulfilled) this.onRejectedCallbacks.push(handleRejected) &#125; &#125;) return promise &#125;&#125; finally无论成功或者失败都会执行 12345678class Promise &#123; finally(callback) &#123; return this.then( value =&gt; Promise.resolve(callback()).then(() =&gt; value), reason =&gt; Promise.resolve(callback()).then(() =&gt; &#123; throw reason &#125;) ) &#125;&#125; all 返回一个新的 promise 将所有的结果都保存在 result 中，当 index === values.length 时，resolve(result) 123456789101112131415161718192021222324Promise.all = function (values) &#123; return new Promise((resolve, reject) =&gt; &#123; const result = [] let index = 0 function processData(key, value) &#123; result[key] = value index += 1 if (values.length === index) &#123; resolve(result) &#125; &#125; for (let i = 0; i &lt; values.length; i++) &#123; let current = values[i] if (isPromise(current)) &#123; current.then(value =&gt; &#123; processData(i, value) &#125;, reject) &#125; else &#123; processData(i, current) &#125; &#125; &#125;)&#125; resolve 如果是普通值，需要将其转化为 promise，后续的才能调用 then1234Promise.resolve = value =&gt; &#123; if (isPromise(value)) return value return new Promise(resolve =&gt; resolve(value))&#125; generator1234567891011const obj = &#123; 0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, *[Symbol.iterator]() &#123; for (let i = 0; i &lt; this.length; i++) &#123; yield this[i] &#125; &#125;&#125; 123456789101112131415161718192021222324252627function* read() &#123; const a = yield &quot;hello&quot; console.log(a) const b = yield &quot;world&quot; console.log(b) return 10&#125;function co(it) &#123; // 循环没有办法异步，递归是可以的 return new Promise((resolve, reject) =&gt; &#123; const next = r =&gt; &#123; const &#123; value, done &#125; = it.next(r) if (done) &#123; resolve(value) &#125; else &#123; Promise.resolve(value).then(res =&gt; &#123; next(res) &#125;, reject) &#125; &#125; next() &#125;)&#125;co(read()).then(res =&gt; &#123; console.log(res)&#125;)","categories":[{"name":"mini","slug":"mini","permalink":"https://wuhongxing.github.io/categories/mini/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://wuhongxing.github.io/tags/promise/"}]},{"title":"clean code","slug":"clean-code","date":"2023-11-29T22:51:06.000Z","updated":"2023-12-13T14:03:14.950Z","comments":true,"path":"2023/11/30/clean-code/","permalink":"https://wuhongxing.github.io/2023/11/30/clean-code/","excerpt":"","text":"前言通常我们学习都是从一门语言开始，但是一旦脱离对应的语言及平台，我们所学的知识可能没有任何用武之地。 而 clean code 是一个通用的技术，除了需要极少量的语言特性。而且这种越底层越通用的技术学会了，能够极大的提升内功，日常迭代过程中的增强我们代码的可维护性，可以帮助我们可以毫不费力的就可以写出质量非常高的代码。 而我们日常做 code review 时，这个也会是一个很大的指导原则。 怎么做？ 命名有意义（参数、方法名、常&#x2F;变量名） 尽量短 (类、函数名、函数体、参数) dry (意图、结构、代码) 保持一致性 命名 精准命名 不能过于宽泛 应该描述意图，而非细节 不要用技术术语命名 用业务语言写代码，建议团队的语汇库 常量、变量、类、字面量命名应该使用名词， 函数命名应该使用动词12345678910111213// 精准命名processChapter(id) =&gt; changeChapterToTranslating(id) =&gt; startTranslation(id)yyyymmdd =&gt; currentDateyyyymmddhhmmss =&gt; currentTime86400000 =&gt; MILLISECONDS_PER_DAY[_, city, zipCode] = address.match(cityZipCodeRegex) || []// 不要用技术术语命名bookList / bookArray =&gt; books 函数 不能有意图重复，只要意图不重复哪怕一模一样也是可以接受的 参数小于等于2个 函数行数小于20行 保证可测试性123verifyUsername() / verifyPassword()createElement(&#x27;div&#x27;, &#123;...props&#125;) 参数 remove flag argument 动静分离，如果一个参数他们的字段变化频率并不一致时，考虑拆分他们到不同的对象中 聚沙成塔：如果参数很多时，应该封装成对象。如果些对象还具有某些行为，封装成类1createFile(isTemp) =&gt; createFile() + createTempFile() 类 职责单一、尽量小（字段少、参数少） 字段分组 - 和参数的动静分离对应 控制语句 卫语句: 提前 return 判断条件重复时可以状态模式&#x2F;策略模式(可以使用表单法来构造) - 开闭原则的体现12345678if (xxx) &#123;&#125; else &#123;&#125;=&gt;if (xxx) return xxxreturn xxx 12345678910111213141516171819202122232425262728293031323334353637383940414243444546function getPrice(type) &#123; switch(type) &#123; case .type1: return price * 0.8 case .type2: return price * 0.7 case .type3: return price * 0.6 &#125;&#125;function getEpubPrice() &#123; switch(type) &#123; case .type1: return price * 0.85 case .type2: return price * 0.75 case .type3: return price * 0.65 &#125;&#125;=&gt;interface Type &#123; getPrice() getEpubPrice()&#125;class Type1 implements Type &#123; getPrice() getEpubPrice()&#125;class Type2 implements Type &#123; getPrice() getEpubPrice()&#125;class Type3 implements Type &#123; getPrice() getEpubPrice()&#125;switch(type) &#123; case .type1: return new Type1() case .type2: return new Type2() case .type3: return new Type3()&#125;// 或者使用表单法&#123;type1: new Type1(), type2: new Type2(), type3: new Type3()&#125;[type]function getPrice() &#123; return type.getPrice()&#125;function getEpubPrice() &#123; return type.getEpubPrice()&#125; 封装 避免火车残骸代码（迪米特法则&#x2F;最少知道原则的体现） 基本类型偏执（这个可以使用 ts 解决） 一次性完成变量的初始化 增加防腐层，主要在于判断是不是有可能被替换。比如我完成一些功能后将其发送到钉钉，但是这个完全可能被替换，那么这个时候，我们是不能在业务直接调用，而应该增加防腐层。（依赖倒置原则的体现 - 高层不应该依赖低层，二者都应该依赖抽象。抽象不依赖于细节，细节应该依赖于抽象。） 格外说一点，就是这个具体的实例到底是在哪个类去初始化，是需要根据具体情况去判断的。比如这个 FailureService 如果不同的业务是不同的，那么就要放到外部去初始化，而如果 FailureService 是相同的，只是后期有可能集体替换，那么则需要放到 Test 初始化，以防陷入霰弹式修改的错误。 12345678910111213141516171819202122232425262728293031323334a.b.c.d =&gt; a.bbnumber =&gt; type Money = numberlet value = &#x27;&#x27;if (xxx) value = xxxelse value = xxx=&gt;getValue() &#123; if (xxx) return xxx return xxx&#125;class Test &#123; feishuService sendBook() &#123; try &#123;&#125; catch(error) &#123; feishuService.send(error) &#125; &#125;&#125;=&gt;interface FailureService &#123; send(error)&#125;class FeishuService implements FailureService &#123;&#125;class Test &#123; failureService: FailureService sendBook() &#123; try &#123;&#125; catch(error) &#123; failureService.send(error) &#125; &#125;&#125; 引用 clean-code-javascript 极客时间《代码之丑》","categories":[{"name":"设计模式","slug":"设计模式","permalink":"https://wuhongxing.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"clean code","slug":"clean-code","permalink":"https://wuhongxing.github.io/tags/clean-code/"}]},{"title":"模板引擎","slug":"template-engine","date":"2023-11-29T22:51:06.000Z","updated":"2023-12-03T09:36:25.330Z","comments":true,"path":"2023/11/30/template-engine/","permalink":"https://wuhongxing.github.io/2023/11/30/template-engine/","excerpt":"","text":"什么是模板引擎模板引擎是一种用于生成 HTML 页面的工具，它可以将数据插入到 HTML 页面中，从而生成完整的 HTML 页面。 实现一个 mini-ejs前置准备 如何执行一段字符串中的 JavaScript 代码？ 方案一: 使用 eval() 12const str = console.log(&#x27;hello world&#x27;)eval(str) 方案二: 使用 new Function() 123const str = &#x27;console.log(&quot;hello world&quot;)&#x27;const fn = new Function(str)fn() 如何传递参数？ 123const str = &#x27;console.log(&quot;hello world&quot;, a, b)&#x27;const fun = new Function(&quot;a&quot;, &quot;b&quot;, str)fun(1, 2) 优化: 封装成对象传递 123const str = &#x27;console.log(&quot;hello world&quot;, obj.a, obj.b)&#x27;const fun = new Function(&quot;obj&quot;, str)fun(&#123; a: 1, b: 2 &#125;) 再优化: 使用 with 语句 123const str = &#x27;with(obj) &#123;console.log(&quot;hello world&quot;, a, b)&#125;&#x27;const fun = new Function(&quot;obj&quot;, str)fun(&#123; a: 1, b: 2 &#125;) 开始实现这个是 ejs 中的内容 12345&#123;% if (isShow) &#123; %&#125;&lt;div&gt;&#123;%= name %&#125;&lt;/div&gt;&#123;% &#125; else &#123; %&#125;&lt;div&gt;age: &#123;%= age %&#125;&lt;/div&gt;&#123;% &#125; %&#125; 解析变量 123456// 将 &#123;%= 解析为 $&#123;，将 %&#125; 解析为 &#125;// `&lt;div&gt;&#123;%= name %&#125;&lt;/div&gt;` =&gt; `&lt;div&gt;$&#123;name&#125;&lt;/div&gt;`let temp = &quot;with(obj) &#123; return `&quot; + content.replace(/\\&#123;\\%\\=([^\\&#125;]+)\\%\\&#125;/g, ($0, $1) =&gt; `\\$\\&#123;$&#123;$1.trim()&#125;\\&#125;`) + &quot;`&#125;&quot; 剥离其中的 js 语句 123456789101112131415161718// 将 %&#123; 变为 `，将 %&#125; 变为 str += `with(obj) &#123; return `&#123;% if (isShow) &#123; %&#125;&lt;div&gt;$&#123;name&#125;&lt;/div&gt;&#123;% &#125; else &#123; %&#125;&lt;div&gt;age: $&#123;age&#125;&lt;/div&gt;&#123;% &#125; %&#125;`&#125;// 就可以转化为下面的结构let str = &#x27;&#x27;with(obj) &#123; return str += ``if (isShow) &#123; str += `&lt;div&gt;$&#123;name&#125;&lt;/div&gt;`&#125; else &#123; str += `&lt;div&gt;age: $&#123;age&#125;&lt;/div&gt;`&#125; str += ``&#125;return str 12345let temp = &quot;let str = &#x27;&#x27;; with(obj) &#123; str += `&quot; + content.replace(/\\&#123;\\%\\=([^\\&#125;]+)\\%\\&#125;/g, ($0, $1) =&gt; `\\$\\&#123;$&#123;$1.trim()&#125;\\&#125;`) + &quot;`&#125; return str&quot;temp = temp.replace(/\\&#123;\\%([^\\%]+)\\%\\&#125;/g, ($0, $1) =&gt; `\\`\\n$&#123;$1&#125;str+=\\``) 构建函数并执行123456789const build = (template, data) =&gt; &#123; const fn = new Function(&quot;obj&quot;, template) return fn(data)&#125;const res = build(temp, &#123; name: &quot;whx111&quot;, age: &quot;100&quot;, isShow: true&#125;) 完整代码 安全性EJS 实际上是一个 JavaScript 运行时。它的全部工作是执行 JavaScript。如果您运行 EJS 渲染方法而不检查你自己投入，你对结果负责。 简而言之，请勿提交包含以下代码片段的“漏洞”： 123app.get(&#x27;/&#x27;, (req, res) =&gt; &#123; res.render(&#x27;index&#x27;, req.query);&#125;); 参考SECURITY.md模板引擎是什么？","categories":[{"name":"mini","slug":"mini","permalink":"https://wuhongxing.github.io/categories/mini/"}],"tags":[{"name":"模板引擎","slug":"模板引擎","permalink":"https://wuhongxing.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"}]},{"title":"使用 Hexo 搭建博客","slug":"build-blog-with-hexo","date":"2023-11-28T12:47:11.575Z","updated":"2023-11-30T01:38:39.001Z","comments":true,"path":"2023/11/28/build-blog-with-hexo/","permalink":"https://wuhongxing.github.io/2023/11/28/build-blog-with-hexo/","excerpt":"","text":"前置准备node 环境、github 账号、VPN 开始 安装 hexo-cli 1npm install -g hexo-cli 生成 blog 123hexo init blogcd blognpm install 部署3.1 申请一个新的 git 仓库：https://github.com/wuhongxing/wuhongxing.github.io 3.2 重写 _config.yml 中的 deploy 配置 12345deploy: type: git repo: https://github.com/wuhongxing/wuhongxing.github.io.git branch: main message: 初次提交 3.3 安装插件 1npm install hexo-deployer-git --save 3.4 执行 yarn clean &amp; yarn deploy 即可然后就可以打开 wuhongxing.github.io 就可以看见我们的博客了。 开始写作 执行 yarn server，启动一个本地服务，打开页面后，保存更改的内容就能实时看到 创建新的文章或者页面，可以使用下面的命令，也可以手动 123hexo new [layout] &lt;title&gt;# exhexo new post &#x27;test&#x27; 主题、插件 可以到 https://hexo.io/themes/ 上面挑一个自己喜欢的 安装主题 2.1 git clone 到 theme 文件夹中 2.2 安装依赖 12345npm install hexo-wordcount --savenpm install hexo-generator-json-content --savenpm install hexo-generator-feed --savenpm install hexo-generator-sitemap --savenpm install hexo-generator-baidu-sitemap --save 2.3 在 theme/pure/_config.yml 中开启 1234567busuanzi: enable: true # 不蒜子统计postCount: enable: true # 是否开启文章字数统计 wordcount: true # 文章字数统计 min2read: true 将 blog/_config.yml 中的 theme 字段改为你刚才的主题名称 最后执行 yarn server 就可以看到效果了 参考 零花费白嫖：免费利用Hexo和GitHub打造个人博客 官方文档 pure","categories":[],"tags":[{"name":"hexo","slug":"hexo","permalink":"https://wuhongxing.github.io/tags/hexo/"}]}],"categories":[{"name":"mini","slug":"mini","permalink":"https://wuhongxing.github.io/categories/mini/"},{"name":"设计模式","slug":"设计模式","permalink":"https://wuhongxing.github.io/categories/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"}],"tags":[{"name":"promise","slug":"promise","permalink":"https://wuhongxing.github.io/tags/promise/"},{"name":"clean code","slug":"clean-code","permalink":"https://wuhongxing.github.io/tags/clean-code/"},{"name":"模板引擎","slug":"模板引擎","permalink":"https://wuhongxing.github.io/tags/%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E/"},{"name":"hexo","slug":"hexo","permalink":"https://wuhongxing.github.io/tags/hexo/"}]}